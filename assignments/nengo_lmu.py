import nengoimport numpy as npdef make_delay_network(q, theta):    Q = np.arange(q, dtype=np.float64)    R = (2 * Q + 1)[:, None] / theta    j, i = np.meshgrid(Q, Q)    A = np.where(i < j, -1, (-1.)**(i - j + 1)) * R    B = (-1.)**Q[:, None] * R    return A, B    def make_nef_lti(tau, A, B):    Ap = tau * A + np.eye(A.shape[0])    Bp = tau * B    return Ap, Bpdef make_delay_decoder(q, thetap, theta=1.0):    ts = np.array(thetap / theta) # Compute the ratio between thetap and theta    return np.array([np.atleast_1d(    # Evaluate the Legendre polynomial of order "i" shifted to [0, 1] at "ts"    np.polynomial.Legendre([0] * i + [1], [0, 1])(ts)) for i in range(q)])    q, theta, tau = 6, 0.5, 0.1Ap, Bp = make_nef_lti(tau, *make_delay_network(q, theta)) #dec_250 = make_delay_decoder(q, 0.25, theta) # 250ms delaywith nengo.Network() as model:    nd_in = nengo.Node(nengo.processes.WhiteSignal(    high=2.0, period=10.0, rms=0.5))    nd_out = nengo.Node(size_in=1)    ens_x = nengo.Ensemble(    n_neurons=500, dimensions=q,    intercepts=nengo.dists.CosineSimilarity(q + 2))    nengo.Connection(nd_in, ens_x, transform=Bp, synapse=tau)    nengo.Connection(ens_x, ens_x, transform=Ap, synapse=tau)    nengo.Connection(ens_x, nd_out, transform=dec_250.T)